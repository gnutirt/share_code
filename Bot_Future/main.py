

# def monitor_positions():
#     """ Lu·ªìng ri√™ng ki·ªÉm tra TP/SL v√† ƒë√≥ng v·ªã th·∫ø khi c·∫ßn. """
#     while True:
#         try:
#             logging.info("\nüîÑ [Monitor] Ki·ªÉm tra v·ªã th·∫ø m·ªü ƒë·ªÉ ƒë√≥ng n·∫øu ƒë·∫°t TP/SL ho·∫∑c FORCE_TAKE_PROFIT...\n")
#             action_futures.summary_profit()
#             active_positions = action_futures.get_active_trades()
           
#             if not active_positions:
#                 time.sleep(botConfig.CHECK_PROFIT_INTERVAL)
#                 continue

#             # logging.info("\nüîÑ Ki·ªÉm tra v·ªã th·∫ø m·ªü ƒë·ªÉ ƒë√≥ng n·∫øu ƒë·∫°t TP/SL ho·∫∑c FORCE_TAKE_PROFIT...\n")     
#             atr_data = strategyChoose.tech_data_furtures()
#             atr_value = atr_data[-1]["atr"] if atr_data else None
            
#             for pos in active_positions:
#                 symbol = pos["symbol"]
#                 entry_price = float(pos["entryPrice"])
#                 position_size = float(pos["positionAmt"])
#                 current_price = float(pos["markPrice"])
#                 unrealized_profit = float(pos["unRealizedProfit"])  # L·ª£i nhu·∫≠n ch∆∞a th·ª±c hi·ªán

#                 # T√≠nh to√°n Take Profit (TP) v√† Stop Loss (SL)
#                 take_profit_price = entry_price + (atr_value * 2)
#                 stop_loss_price = entry_price - (atr_value * max(botConfig.ATR_MULTIPLIER, 2 if atr_value < botConfig.MIN_ATR else 1.5))

#                 # T√≠nh ph·∫ßn trƒÉm l·ªùi/l·ªó so v·ªõi v·ªën ban ƒë·∫ßu
#                 profit_percent = (current_price - entry_price) / entry_price * 100 if position_size > 0 else (entry_price - current_price) / entry_price * 100

#                 logging.info(f"üìä V·ªã th·∫ø {symbol} | Entry: {entry_price:.2f} | Current: {current_price:.2f} | PnL: {unrealized_profit:.2f} USDT ({profit_percent:.2f}%)")

#                 # üöÄ Ki·ªÉm tra FORCE_TAKE_PROFIT (ƒê√≥ng ngay khi l·ª£i nhu·∫≠n >= m·ª©c c√†i ƒë·∫∑t)
#                 if unrealized_profit >= botConfig.FORCE_TAKE_PROFIT:
#                     if position_size > 0:
#                         close_order = action_futures.close_long_position(symbol)
#                         if close_order:
#                             logger.log_trade_closure(symbol, "LONG", entry_price, current_price, "FORCE_TAKE_PROFIT", unrealized_profit, profit_percent)
#                             logging.info(f"‚úÖ ƒê√≥ng LONG {symbol} v√¨ ƒë·∫°t FORCE_TAKE_PROFIT: {unrealized_profit:.2f} USDT")
#                     elif position_size < 0:
#                         close_order = action_futures.close_short_position(symbol)
#                         if close_order:
#                             logger.log_trade_closure(symbol, "SHORT", entry_price, current_price, "FORCE_TAKE_PROFIT", unrealized_profit, profit_percent)
#                             logging.info(f"‚úÖ ƒê√≥ng SHORT {symbol} v√¨ ƒë·∫°t FORCE_TAKE_PROFIT: {unrealized_profit:.2f} USDT")

#                 # üöÄ N·∫øu ƒë·∫°t Take Profit (TP) ‚Üí ƒê√≥ng v·ªã th·∫ø
#                 elif position_size > 0 and current_price >= take_profit_price:
#                     close_order = action_futures.close_long_position(symbol)
#                     if close_order:
#                         logger.log_trade_closure(symbol, "LONG", entry_price, current_price, "TAKE_PROFIT", unrealized_profit, profit_percent)
#                         logging.info(f"‚úÖ ƒê√≥ng LONG {symbol} t·∫°i {current_price:.2f} USDT | TP ƒë·∫°t {take_profit_price:.2f} USDT")

#                 elif position_size < 0 and current_price <= take_profit_price:
#                     close_order = action_futures.close_short_position(symbol)
#                     if close_order:
#                         logger.log_trade_closure(symbol, "SHORT", entry_price, current_price, "TAKE_PROFIT", unrealized_profit, profit_percent)
#                         logging.info(f"‚úÖ ƒê√≥ng SHORT {symbol} t·∫°i {current_price:.2f} USDT | TP ƒë·∫°t {take_profit_price:.2f} USDT")

#                 # ‚ùå N·∫øu ch·∫°m Stop Loss (SL) ‚Üí ƒê√≥ng v·ªã th·∫ø
#                 elif position_size > 0 and current_price <= stop_loss_price:
#                     close_order = action_futures.close_long_position(symbol)
#                     if close_order:
#                         logger.log_trade_closure(symbol, "LONG", entry_price, current_price, "STOP_LOSS", unrealized_profit, profit_percent)
#                         logging.warning(f"‚ùå C·∫Øt l·ªó LONG {symbol} t·∫°i {current_price:.2f} USDT | SL ƒë·∫°t {stop_loss_price:.2f} USDT")

#                 elif position_size < 0 and current_price >= stop_loss_price:
#                     close_order = action_futures.close_short_position(symbol)
#                     if close_order:
#                         logger.log_trade_closure(symbol, "SHORT", entry_price, current_price, "STOP_LOSS", unrealized_profit, profit_percent)
#                         logging.warning(f"‚ùå C·∫Øt l·ªó SHORT {symbol} t·∫°i {current_price:.2f} USDT | SL ƒë·∫°t {stop_loss_price:.2f} USDT")

#         except Exception as e:
#             logging.error(f"‚ùå L·ªói trong qu√° tr√¨nh ki·ªÉm tra TP/SL: {e}")

#         time.sleep(botConfig.CHECK_PROFIT_INTERVAL)  # ƒê·ª£i tr∆∞·ªõc khi ki·ªÉm tra l·∫°i
import time
import logging
from Binance_bot_trade.config import botConfig
from Binance_bot_trade.actionBot import action_futures, strategyChoose
from Binance_bot_trade.analysis import update_price
import Binance_bot_trade.utils.sync_time as sync_times
import Binance_bot_trade.utils.logger as logger
import threading
import queue
 

def monitor_positions():
    """Lu·ªìng ki·ªÉm tra TP/SL & ƒë√≥ng v·ªã th·∫ø khi ƒë·∫°t l·ª£i nhu·∫≠n mong mu·ªën."""
    while True:
        try:
            logging.info("\nüîÑ [Monitor] Ki·ªÉm tra v·ªã th·∫ø m·ªü ƒë·ªÉ c·∫≠p nh·∫≠t TP/SL & FORCE_TAKE_PROFIT...\n")

            # ‚úÖ L·∫•y danh s√°ch v·ªã th·∫ø ƒëang m·ªü
            active_positions = action_futures.get_active_trades()
            action_futures.summary_profit()
            symbol = botConfig.TRADE_PAIRS["FUTURES"][0]
            action_futures.set_tp_sl_for_positions_for_multi_open_positions(symbol)  
            if not active_positions:
                time.sleep(botConfig.CHECK_PROFIT_INTERVAL)
                continue
            

            # üî• **B∆∞·ªõc 1: Adaptive TP d·ª±a tr√™n bi·∫øn ƒë·ªông BTC 24h**
            print("[monitor_positions]üî• B∆∞·ªõc 1: Adaptive TP d·ª±a tr√™n bi·∫øn ƒë·ªông BTC 24h:")
            btc_24h_change = update_price.get_btc_24h_change()
            if btc_24h_change is not None:
                if btc_24h_change > 10:  # BTC tƒÉng m·∫°nh
                    adaptive_tp_percent = 7
                    logging.info(f"üìä BTC tƒÉng {btc_24h_change:.2f}% trong 24h, tƒÉng TP l√™n 7%")
                elif btc_24h_change < -10:  # BTC gi·∫£m m·∫°nh
                    adaptive_tp_percent = 3
                    logging.info(f"üìä BTC gi·∫£m {btc_24h_change:.2f}% trong 24h, gi·∫£m TP xu·ªëng 3%")
                else:  # Gi·ªØ m·ª©c TP m·∫∑c ƒë·ªãnh
                    adaptive_tp_percent = 5       
            # üî• B∆∞·ªõc 2: Nh√≥m v·ªã th·∫ø theo symbol v√† t√≠nh t·ªïng l·ª£i nhu·∫≠n
            print("[monitor_positions]üî• B∆∞·ªõc 2: Nh√≥m v·ªã th·∫ø theo symbol v√† t√≠nh t·ªïng l·ª£i nhu·∫≠n:")
            positions_by_symbol = {}
            for pos in active_positions:
                symbol = pos["symbol"]
                if symbol not in positions_by_symbol:
                    positions_by_symbol[symbol] = {"LONG": None, "SHORT": None, "total_profit": 0}
                pos_data = {
                    "size": float(pos["positionAmt"]),
                    "profit": float(pos["unRealizedProfit"]),
                    "entry_price": float(pos["entryPrice"]),
                    "mark_price": float(pos["markPrice"])
                }
                if pos_data["size"] > 0:
                    positions_by_symbol[symbol]["LONG"] = pos_data
                else:
                    positions_by_symbol[symbol]["SHORT"] = pos_data
                positions_by_symbol[symbol]["total_profit"] += pos_data["profit"]

            # üî• B∆∞·ªõc 3: Ki·ªÉm tra v√† ƒë√≥ng v·ªã th·∫ø
            print("[monitor_positions]üî• B∆∞·ªõc 3: Ki·ªÉm tra v√† ƒë√≥ng v·ªã th·∫ø:")
            for symbol, pos_data in positions_by_symbol.items():
                total_profit = pos_data["total_profit"]
                long_pos = pos_data["LONG"]
                short_pos = pos_data["SHORT"]
                adaptive_tp_value = botConfig.GRID_ORDER_VALUE * adaptive_tp_percent / 100
                if long_pos:
                    profit_long = long_pos["profit"]
                else:
                    profit_long = 0

                if short_pos:
                    profit_short = short_pos["profit"]
                else:
                    profit_short = 0
                print(f"Total_profit: {total_profit:.2f}, profit_long: {profit_long}, profit_short: {profit_short}")
                # T√≠nh ph·∫ßn trƒÉm l·ªùi/l·ªó so v·ªõi v·ªën ban ƒë·∫ßu
              
                
                # ‚úÖ Tr∆∞·ªùng h·ª£p 1: T·ªïng l·ª£i nhu·∫≠n ƒë·∫°t ng∆∞·ª°ng ‚Üí ƒê√≥ng c·∫£ LONG v√† SHORT + Clear orders
                if total_profit >= botConfig.FORCE_TAKE_PROFIT:
                    if long_pos or short_pos:
                        # T√≠nh ph·∫ßn trƒÉm l·ªùi/l·ªó
                        long_profit_percent = 0
                        short_profit_percent = 0
                        if long_pos:
                            long_profit_percent = ((long_pos["mark_price"] - long_pos["entry_price"]) / long_pos["entry_price"]) * 100
                        if short_pos:
                            short_profit_percent = ((short_pos["entry_price"] - short_pos["mark_price"]) / short_pos["entry_price"]) * 100
                        close_long_short_order = action_futures.close_all_positions()                     
                        if close_long_short_order:
                            logging.info(f"‚úÖ ƒê√≥ng LONG & SHORT {symbol} (T·ªïng l√£i: {total_profit:.2f} USDT)")
                            logger.log_trade_closure(symbol, "LONG", long_pos["entry_price"], long_pos["mark_price"], "FORCE_TAKE_PROFIT", long_pos["profit"],long_profit_percent)
                            logger.log_trade_closure(symbol, "SHORT", short_pos["entry_price"], short_pos["mark_price"], "FORCE_TAKE_PROFIT", short_pos["profit"],short_profit_percent)               

                        # üî• Clear to√†n b·ªô l·ªánh treo ƒë·ªÉ b·∫Øt ƒë·∫ßu chu tr√¨nh m·ªõi
                        open_orders_list = action_futures.get_pending_orders(symbol)
                        if open_orders_list:
                            action_futures.cancel_all_orders(symbol)
                            time.sleep(30)  # ƒê·ª£i l·ªánh h·ªßy ho√†n t·∫•t
                            logging.info(f"‚úÖ ƒê√£ x√≥a s·∫°ch l·ªánh treo cho {symbol}, s·∫µn s√†ng chu tr√¨nh m·ªõi")
                            
                        continue

                # ‚úÖ Tr∆∞·ªùng h·ª£p 2: L·ª£i nhu·∫≠n ri√™ng l·∫ª ƒë·∫°t ng∆∞·ª°ng l·ªõn ‚Üí ƒê√≥ng v·ªã th·∫ø ƒë√≥
                if long_pos and long_pos["profit"] >= max(botConfig.FORCE_TAKE_PROFIT, adaptive_tp_value * 1.5):
                    # T√≠nh ph·∫ßn trƒÉm l·ªùi/l·ªó
                    long_profit_percent = 0
                    short_profit_percent = 0
                    if long_pos:
                        long_profit_percent = ((long_pos["mark_price"] - long_pos["entry_price"]) / long_pos["entry_price"]) * 100
                    if short_pos:
                        short_profit_percent = ((short_pos["entry_price"] - short_pos["mark_price"]) / short_pos["entry_price"]) * 100
                    close_order = action_futures.close_long_position(symbol)
                    if close_order:
                        logging.info(f"‚úÖ ƒê√≥ng LONG {symbol} v√¨ l√£i ri√™ng l·∫ª: {long_pos['profit']:.2f} USDT")
                        logger.log_trade_closure(symbol, "LONG", long_pos["entry_price"], long_pos["mark_price"], "FORCE_TAKE_PROFIT", long_pos["profit"],long_profit_percent)
                
                if short_pos and short_pos["profit"] >= max(botConfig.FORCE_TAKE_PROFIT, adaptive_tp_value * 1.5):
                    close_order = action_futures.close_short_position(symbol)
                    if close_order:
                        logging.info(f"‚úÖ ƒê√≥ng SHORT {symbol} v√¨ l√£i ri√™ng l·∫ª: {short_pos['profit']:.2f} USDT")
                        logger.log_trade_closure(symbol, "SHORT", short_pos["entry_price"], short_pos["mark_price"], "FORCE_TAKE_PROFIT", short_pos["profit"],short_profit_percent)
      
        except Exception as e:
            logging.error(f"‚ùå L·ªói trong qu√° tr√¨nh ki·ªÉm tra TP/SL: {e}")

        time.sleep(botConfig.CHECK_PROFIT_INTERVAL)  # ƒê·ª£i tr∆∞·ªõc khi ki·ªÉm tra l·∫°i


def main_loop():
    sync_times.sync_time()
    logging.info("üöÄ B·∫ÆT ƒê·∫¶U CH·∫†Y BOT TRADING...\n")
   

    # üî• B∆∞·ªõc 1: Load c·∫•u h√¨nh bot
    logging.info("üîπ ƒêang t·∫£i c·∫•u h√¨nh t·ª´ botConfig.py...")
    trade_mode = botConfig.TRADE_MODE
    test_mode = botConfig.TEST_MODE
    logging.info(f"üîπ Trade Mode: {trade_mode} | Test Mode: {test_mode}")
    symbol = botConfig.TRADE_PAIRS["FUTURES"][0]
    
 
    while True:
        try:
 

            logging.info("üöÄ KH·ªûI CH·∫†Y MAIN_LOOPS...\n")
            logging.info("\nüîç B∆∞·ªõc 2: C·∫≠p nh·∫≠t gi√° th·ªã tr∆∞·ªùng\n")

            # üî• B∆∞·ªõc 2: C·∫≠p nh·∫≠t gi√° th·ªã tr∆∞·ªùng
            market_prices = update_price.update_prices()
           
            if not market_prices or "futures" not in market_prices:
                logging.warning("‚ö†Ô∏è Kh√¥ng l·∫•y ƒë∆∞·ª£c d·ªØ li·ªáu gi√° Futures, b·ªè qua v√≤ng l·∫∑p n√†y!")
                continue

            symbol = botConfig.TRADE_PAIRS["FUTURES"][0]
            futures_price = market_prices["futures"].get("futures_price")
            logging.info(f"üîπ Gi√° Futures: {futures_price}")

            if futures_price is None:
                logging.warning(f"‚ö†Ô∏è Kh√¥ng l·∫•y ƒë∆∞·ª£c gi√° {symbol}, b·ªè qua giao d·ªãch!")
                continue

            # üî• B∆∞·ªõc 3: L·∫•y danh s√°ch v·ªã th·∫ø & s·ªë l·ªánh ƒëang m·ªü
            logging.info("\nüî• B∆∞·ªõc 3: L·∫•y danh s√°ch v·ªã th·∫ø & s·ªë l·ªánh ƒëang m·ªü\n")
            usdt_balance = action_futures.get_futures_balance("USDT")
            open_orders = action_futures.get_open_order_count() # L·ªánh ƒëang treo
            active_positions = action_futures.get_active_trades() #L·ªánh ƒëang m·ªü v·ªã th·∫ø
            # ‚úÖ **Chia v·ªã th·∫ø th√†nh LONG & SHORT**
            long_positions = [pos for pos in active_positions if pos["positionSide"] == "LONG"]
            short_positions = [pos for pos in active_positions if pos["positionSide"] == "SHORT"]

            open_orders_list = action_futures.get_pending_orders(symbol) 
            order_value = botConfig.GRID_ORDER_VALUE
            leverage = botConfig.TRADE_LEVERAGE
            # filled_trades = action_futures.get_filled_trades(symbol)

            # üî• L·∫•y d·ªØ li·ªáu ATR m·ªõi nh·∫•t
            atr_data = strategyChoose.tech_data_furtures()
            atr_value = atr_data[-1]["atr"] if atr_data else None
      

            open_positions_count = len(active_positions)
            logging.info(f"üîÑ S·ªë l·ªánh m·ªü: {open_orders} | S·ªë v·ªã th·∫ø m·ªü: {open_positions_count}")

       
            if usdt_balance < botConfig.MIN_TRADE_AMOUNT:
                logging.warning("‚ö†Ô∏è Kh√¥ng ƒë·ªß USDT ƒë·ªÉ giao d·ªãch Futures!")
                continue
            
            # üî• B∆∞·ªõc 4: L·∫•y d·ªØ li·ªáu Order Book ƒë·ªÉ tr√°nh ƒë·∫∑t l·ªánh v√†o v√πng thanh kho·∫£n th·∫•p
            logging.info("\nüî• B∆∞·ªõc 4: L·∫•y d·ªØ li·ªáu Order Book ƒë·ªÉ tr√°nh ƒë·∫∑t l·ªánh v√†o v√πng thanh kho·∫£n th·∫•p\n")
            order_book = update_price.get_order_book(symbol)
           
            if order_book:
                best_bid = float(order_book["bids"][0][0])  # √âp ki·ªÉu float
                best_ask = float(order_book["asks"][0][0]) 
                if best_bid < futures_price < best_ask:
                    logging.info(f"üìä ƒê·∫∑t l·ªánh trong v√πng thanh kho·∫£n cao: {best_bid} - {best_ask}")
                else:
                    futures_price = (best_bid + best_ask) / 2 
                    logging.warning(f"‚ö†Ô∏è Gi√° hi·ªán t·∫°i n·∫±m ngo√†i v√πng thanh kho·∫£n, ƒëi·ªÅu ch·ªânh v·ªã tr√≠ ƒë·∫∑t l·ªánh. Gi√° Futures: {futures_price}")
                    

            # üî• B∆∞·ªõc 5: Ki·ªÉm tra l·ªách gi√° l∆∞·ªõi & Adaptive Grid
            logging.info("\nüî• B∆∞·ªõc 5: Ki·ªÉm tra l·ªách gi√° l∆∞·ªõi & Adaptive Grid\n")
            grid_levels = max(botConfig.GRID_LEVELS, int(botConfig.GRID_LEVELS * (max(atr_value, botConfig.MIN_ATR) / futures_price) * botConfig.ADAPTIVE_GRID_SCALING))
            # grid_spacing = max(atr_value / futures_price, botConfig.GRID_SPACING_PERCENT / 100)     
            atr_smooth = sum(entry["atr"] for entry in atr_data[-botConfig.ATR_SMOOTHING_WINDOW:]) / botConfig.ATR_SMOOTHING_WINDOW             
            atr_change = (atr_value - atr_smooth) / atr_smooth
            if atr_change < -0.50:  # ATR gi·∫£m m·∫°nh -> TƒÉng g·∫•p ƒë√¥i s·ªë l·ªánh GRID
                grid_levels = min(grid_levels * 2, botConfig.MAX_GRID_LEVELS)
                logging.info(f"üìä ATR gi·∫£m m·∫°nh (-50%), tƒÉng s·ªë l·ªánh GRID l√™n {grid_levels}")

            elif atr_change > 0.50:  # ATR tƒÉng m·∫°nh -> Gi·∫£m 1/2 s·ªë l·ªánh GRID
                grid_levels = max(grid_levels // 2, botConfig.MIN_GRID_LEVELS)
                logging.info(f"üìä ATR tƒÉng m·∫°nh (+50%), gi·∫£m s·ªë l·ªánh GRID xu·ªëng {grid_levels}")
            price_volatility = abs(futures_price - market_prices["futures"].get("previous_close")) / futures_price            
            grid_spacing = max(atr_smooth / futures_price, botConfig.GRID_SPACING_PERCENT / 100) * (1 + price_volatility)
            grid_spacing = grid_spacing/10
            price_deviation_threshold = grid_levels * grid_spacing*10 #Chia 20 nen phai * 20 lai
            logging.info(f"üìä Adaptive Grid: {grid_levels} ‚Üí {grid_spacing} (D·ª±a tr√™n ATR)")


 

            logging.info("\nüî• T√≠nh to√°n t√¢m l∆∞·ªõi c·∫£i ti·∫øn\n")
            grid_center_price = determine_grid_center(
                futures_price=futures_price,
                active_positions=active_positions,
                open_orders_list=open_orders_list,
                order_book=order_book,
                atr_data=atr_data
            )
            price_deviation = abs(grid_center_price - futures_price) / futures_price
            logging.info(f"üìä T√¢m l∆∞·ªõi m·ªõi: {grid_center_price:.8f} (L·ªách: {price_deviation:.2%})")
          
 

            # üî• Ki·ªÉm tra l·ªách gi√° l∆∞·ªõi
            if price_deviation > price_deviation_threshold:
                logging.warning(f"‚ö†Ô∏è T√¢m l∆∞·ªõi l·ªách {price_deviation:.2%}, ch·ªâ h·ªßy l·ªánh GRID v√† ƒë·∫∑t l·∫°i!")

                # üöÄ L·∫•y danh s√°ch l·ªánh m·ªü
                open_orders_list = action_futures.get_pending_orders(symbol)

                for order in open_orders_list:
                    order_id = order["orderId"]
                    order_type = order["type"]
                    
                    # ‚ùå Ch·ªâ h·ªßy c√°c l·ªánh GRID (LIMIT, STOP_LIMIT) - Gi·ªØ l·∫°i TP/SL
                    if order_type in ["LIMIT", "STOP_LIMIT"]:
                        logging.warning(f"‚ö†Ô∏è H·ªßy l·ªánh GRID: {order['side']} @ {order['price']} (Lo·∫°i: {order_type})")
                        action_futures.cancel_order_orderId(symbol, order_id)

                time.sleep(3)  # Ch·ªù l·ªánh ƒë∆∞·ª£c h·ªßy ho√†n to√†n
                open_orders = action_futures.get_open_order_count()
 

          
            # üî• B∆∞·ªõc 6: Gi√°m s√°t l·ªánh treo
            logging.info("\nüî• B∆∞·ªõc 6: Gi√°m s√°t l·ªánh treo\n")
            
            current_time = int(time.time() * 1000)  # Timestamp hi·ªán t·∫°i (ms)
            for order in open_orders_list:
                order_time = order.get("updateTime")  # Ch·ªâ d√πng updateTime, kh√¥ng fallback sang time

                if order_time is None:
                    logging.warning(f"‚ö†Ô∏è L·ªánh {order['orderId']} kh√¥ng c√≥ updateTime, b·ªè qua!")
                    continue  # Kh√¥ng h·ªßy l·ªánh n√†y ƒë·ªÉ tr√°nh nh·∫ßm l·∫´n

                order_age = (current_time - order_time) / 1000  # Chuy·ªÉn ms ‚Üí gi√¢y

                if order_age > botConfig.MAX_ORDER_WAIT_TIME:
                    logging.warning(f"‚ö†Ô∏è L·ªánh {order['orderId']} ƒë√£ treo {order_age:.2f}s, h·ªßy l·ªánh!")
                    action_futures.cancel_order_orderId(order["symbol"], order["orderId"])  # H·ªßy l·ªánh
                    
            # üî• B∆∞·ªõc 7: ƒê·∫∑t l·ªánh GRID TRADING n·∫øu ch∆∞a ƒë·ªß l·ªánh
          
            # T√≠ch h·ª£p Funding Rate
            funding_rate = update_price.get_funding_rate(symbol)
            if funding_rate is not None:
                logging.info(f"üìä Funding Rate hi·ªán t·∫°i: {funding_rate:.6f}")
                if abs(funding_rate) > 0.001:  # Funding Rate > 0.1%
                    grid_levels = max(grid_levels // 2, botConfig.MIN_GRID_LEVELS)
                    logging.info(f"üìä Funding Rate cao ({funding_rate:.6f}), gi·∫£m l∆∞·ªõi xu·ªëng {grid_levels}")          
            total_grid_orders = grid_levels * 2
            
            print(f"üìä T·ªïng s·ªë l·ªánh GRID: {total_grid_orders}")
            if open_orders < total_grid_orders:
                logging.info(f"üìä GRID TRADING ‚Üí ƒê·∫∑t th√™m l·ªánh cho {symbol} (hi·ªán c√≥ {open_orders}/{total_grid_orders} l·ªánh)")

                missing_orders = total_grid_orders - open_orders
                missing_orders = min(missing_orders, botConfig.MAX_CONCURRENT_TRADES - open_orders)  # Gi·ªõi h·∫°n s·ªë l·ªánh

                # ‚úÖ ƒê·∫£m b·∫£o lu√¥n c√≥ gi√° tr·ªã m·∫∑c ƒë·ªãnh
                existing_buy_orders = set()
                existing_sell_orders = set()
                # üöÄ L·∫•y danh s√°ch l·ªánh m·ªü
                open_orders_list = action_futures.get_pending_orders(symbol)
                if open_orders_list:
                    existing_buy_orders = {order["price"] for order in open_orders_list if order["side"] == "BUY"}
                    existing_sell_orders = {order["price"] for order in open_orders_list if order["side"] == "SELL"}

                if open_orders == 0:
                    for i in range(grid_levels):
                        limit_buy_price = futures_price * (1 - (i + 1) * grid_spacing)
                        limit_sell_price = futures_price * (1 + (i + 1) * grid_spacing)

                        if limit_buy_price not in existing_buy_orders:
                            action_futures.place_limit_long_with_stop_loss(
                                symbol, limit_buy_price, (order_value * leverage) / limit_buy_price
                            )

                        if limit_sell_price not in existing_sell_orders:
                            action_futures.place_limit_short_with_stop_loss(
                                symbol, limit_sell_price, (order_value * leverage) / limit_sell_price
                            )

                else:
                    latest_filled_price = market_prices["futures"].get("futures_price")
             

                    for i in range((missing_orders + 1) // 2):
                        limit_buy_price = latest_filled_price * (1 - (i + 1) * grid_spacing)
                        limit_sell_price = latest_filled_price * (1 + (i + 1) * grid_spacing)

                        if abs(limit_buy_price - limit_sell_price) < grid_spacing * 0.5:
                            logging.warning("‚ö†Ô∏è Kho·∫£ng c√°ch l·ªánh qu√° nh·ªè, ƒëi·ªÅu ch·ªânh l·∫°i!")
                            continue

                        if limit_buy_price not in existing_buy_orders:
                            action_futures.place_limit_long_with_stop_loss(
                                symbol, limit_buy_price, (order_value * leverage) / limit_buy_price
                            )

                        if limit_sell_price not in existing_sell_orders:
                            action_futures.place_limit_short_with_stop_loss(
                                symbol, limit_sell_price, (order_value * leverage) / limit_sell_price
                            )

                time.sleep(1)  # ƒê·ª£i API c·∫≠p nh·∫≠t danh s√°ch l·ªánh
                open_orders_list = action_futures.get_pending_orders(symbol)  # C·∫≠p nh·∫≠t danh s√°ch l·ªánh m·ªü
 
        except Exception as e:
            logging.error(f"‚ùå L·ªói trong qu√° tr√¨nh ch·∫°y bot: {e}")

        logging.info("\n‚è≥ ƒê·ª£i tr∆∞·ªõc khi ch·∫°y v√≤ng ti·∫øp theo...\n")
       
        time.sleep(botConfig.CHECK_ORDER_INTERVAL)
        sync_times.sync_time()

# üî• H√†m ph·ª• tr·ª£: T√≠nh trung b√¨nh gi√° v√†o l·ªánh c·ªßa v·ªã th·∫ø
def calculate_position_center(active_positions):
    if not active_positions:
        return None
    total_position_size = sum(abs(float(pos["positionAmt"])) for pos in active_positions)
    if total_position_size == 0:
        return None
    weighted_entry_price = sum(float(pos["entryPrice"]) * abs(float(pos["positionAmt"])) for pos in active_positions)
    return weighted_entry_price / total_position_size
# üî• X√°c ƒë·ªãnh t√¢m l∆∞·ªõi c·∫£i ti·∫øn
def determine_grid_center(futures_price, active_positions, open_orders_list, order_book, atr_data):
    # 1. Gi√° trung b√¨nh c√≥ tr·ªçng s·ªë c·ªßa v·ªã th·∫ø m·ªü
    position_center = calculate_position_center(active_positions)
    
    # 2. Trung b√¨nh gi√° t·ª´ l·ªánh treo (n·∫øu c√≥)
    order_center = None
    if open_orders_list:
        buy_orders = [float(order["price"]) for order in open_orders_list if order["side"] == "BUY"]
        sell_orders = [float(order["price"]) for order in open_orders_list if order["side"] == "SELL"]
        if buy_orders and sell_orders:
            min_buy_price = min(buy_orders)
            max_sell_price = max(sell_orders)
            order_center = (min_buy_price + max_sell_price) / 2

    # 3. Trung b√¨nh Order Book (VWAP ng·∫Øn h·∫°n gi·∫£ l·∫≠p)
    book_center = None
    if order_book:
        best_bid = float(order_book["bids"][0][0])
        best_ask = float(order_book["asks"][0][0])
        book_center = (best_bid + best_ask) / 2

    # 4. ƒêi·ªÅu ch·ªânh d·ª±a tr√™n xu h∆∞·ªõng ATR (n·∫øu c√≥ d·ªØ li·ªáu)
    atr_shift = 0
    if atr_data and len(atr_data) >= 2:
        atr_current = atr_data[-1]["atr"]
        atr_previous = atr_data[-2]["atr"]
        atr_change = (atr_current - atr_previous) / atr_previous
        # N·∫øu ATR tƒÉng m·∫°nh (> 50%), d·ªãch t√¢m l∆∞·ªõi theo h∆∞·ªõng gi√° hi·ªán t·∫°i
        if atr_change > 0.5:
            atr_shift = futures_price * 0.01  # D·ªãch 1% theo h∆∞·ªõng tƒÉng
        elif atr_change < -0.5:
            atr_shift = -futures_price * 0.01  # D·ªãch 1% theo h∆∞·ªõng gi·∫£m

    # 5. K·∫øt h·ª£p c√°c y·∫øu t·ªë v·ªõi tr·ªçng s·ªë
    candidates = [
        (position_center, 0.4 if position_center else 0),  # 40% n·∫øu c√≥ v·ªã th·∫ø
        (order_center, 0.3 if order_center else 0),        # 30% n·∫øu c√≥ l·ªánh treo
        (book_center, 0.2 if book_center else 0),          # 20% t·ª´ Order Book
        (futures_price, 0.1),                              # 10% t·ª´ gi√° hi·ªán t·∫°i
    ]
    total_weight = sum(weight for _, weight in candidates)
    if total_weight == 0:
        return futures_price  # D·ª± ph√≤ng n·∫øu kh√¥ng c√≥ d·ªØ li·ªáu
    
    grid_center_price = sum(value * weight for value, weight in candidates if value) / total_weight
    grid_center_price += atr_shift  # ƒêi·ªÅu ch·ªânh theo ATR
    
    return grid_center_price

def main_start():
    logging.info("üöÄ KH·ªûI ƒê·ªòNG C·∫¢ HAI LU·ªíNG...\n")
    monitor_thread = threading.Thread(target=monitor_positions, daemon=True)
    main_thread = threading.Thread(target=main_loop, daemon=True)
    monitor_thread.start()
    main_thread.start()
    try:
        while True:
            time.sleep(10)
    except KeyboardInterrupt:
        logging.info("‚èπ D·ª´ng bot...")

if __name__ == "__main__":
    main_start()
     

